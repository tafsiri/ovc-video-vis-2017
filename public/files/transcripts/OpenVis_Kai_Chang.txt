D3 with Canvas
Kai Chang

>> Hey, everybody.  Ooo!  That's exciting.  Go ahead and get to your seats.  Get your coffee.  Get your chatting over.  Or go outside.  Just kidding.  No, not kidding.  I'm just going to stand here and awkwardly shoot guilty glances at you guys.  That's fine.  Nope.  I will also ask you guys during talks if you are getting coffee or water or any other beverage in a clinky container, do your best not to clink it too much with other clinky containers.  Or surfaces.  I'm not sure how those noises are happening.  But I know who you are.  It's one of you 470 people having a warm beverage.
Cool.  All right.  Well, that was two amazing talks to start the day with.  And so appropriate and so thoughtful and thoughtprovoking.  And someone was there  I think a lot of us cried for five minutes at least.  I appreciate a conference that can make me cry.  Anyways, I'm excited to introduce our next speaker.  Kai is returning.  He spoke at OpenVis Conf many years ago about visually exploring multidimensional data and shared awesome open source work.  Make use of Canvas.  One of the first projects that has done that.  Worked as a design technologist and the coorganizer of the Bay area D3 user group and the Conf.  One of the best communities in data visualization.  So please give him a warm welcome.
[ Applause ]
>> Thanks, Irene.  Let's see.  My talks are on the blocks page, D3 and canvas here.  I'm going to go fast.  So I don't know if you'll be able to read everything on the slide.  My talk is a little bit of a split personality.  A little bit of tips and tricks, and about learning D3 and programming in general.  We're talking about pixels and subpixels, which are  I don't know if you have ever seen one of these since the iPhone 4 came out.  Because they are so small.  I think a child nowadays may not even be aware that, you know, displays are made of pixels.
I mean, nowadays there are probably billions of pixels in this room.  And think about all the computational power that goes into driving those pixels.  This is a picture of this display here.  It's a macro mechanic.  Let me zoom in a little bit more.  This is a real photo of this computer this morning.  This is what pixels look like.  They are red, green, and blue, usually.  They can come in a couple different layouts.  I think it's IPS.  This is a kind of standard layout.  And you can control each of these, you know, red, green, and blue values individually.
And once you have enough of them, and they're small enough, you don't see red, green and blue anymore.  You get colormixing effects.  And, you know, it happens on the surface of your eye, on your retina.  This is an image, if you pull out my eye and slice it in half sorry.  This way.  Slice it in half.  You know, the retina are those cones.  And cones and rods.  Cones are the ones that really sort of peak in the center of the eye, they're sensitive to color.  Color and shapes.  And then we have the sort of layer of processing bipolar cells, ganglion cells that actually produce a lot of  do a lot of visual processing right there on the eye before the information gets passed through the optic nerve.  Through the optic chasm, and the visual cortex.  Our eyes are directly connected to our brains.  The images that go into our eyes, they just reverberate through your whole brain.
So we want to control these pixels and draw things on the screen, you know, that give us ideas.  And in order to do that we're going to have to deal with computers.  And programming languages and all this stuff that we've created.
I mean, there's this  I mean, it's really the photons in this reaction that's happening in the eye and the ideas in our brains, that's what we care about.  But we have to pick something.  This talk is about Canvas.  It is  it's an API, a JavaScript API developed by Apple in 2004.  It was  there's a specification created by the WG a few years later.  Basically in all browsers.  It's been that way for about a decade, at least.  It works on mobile phones.  Pretty much every device.  I think it could drive most of the billions of the pixels in this room.  Except maybe like your camera view finder or something.
In order to program on Canvas, we're going to need to use JavaScript.  This means number strings, bullions.  Arrays, which are a great data structure if you're interested in visualization.  They have a scary name, array.  Arrays have a scary name, arrays functions.  Don't worry about it, they're cool.  And methods on arrays, like map filtering for each.
There was a talk given last year at OpenVis Conf by Mariko Kosaka.  It's about the Canvas, the RGB, red, green, blue, and there's an alpha value at every pixel.  There's a flat array ray.  And that's what the Canvas data is.  And Mariko likes mapping them and reducing them, but does it in the physical world.  So these are the metaphors, you know, that are useful when you're learning a programming language, especially for the first time.
Because you know, something real is happening in the Computer.  The words don't necessarily correspond to exactly what is happening in there.  And actually, it's sometimes so complex what's happening in here.  It's overwhelming to think about.  So having ideas like about mapping, which is basically transforming a set into something else, or reducing, which is, you know, taking a set and sort of turning it into something smaller, generally.  It's useful.
We need some boilerplate.  Boilerplate sucks.  Especially for beginners.  Because you can't do anything until you have it.  The nice thing about Canvas, it's not too bad.  You need one Canvas element and one script element to put your JavaScript in.  And you need this scary stuff, some DOM selection.  And then you need to get the canvas and render on the 2D context.  So almost everything I talk about for the rest of the talk in terms of rendering is going to happen on this 2D context.
So here's some basic drawing with Canvas.  Just filling reqs.  The Canvas context has a bunch of properties like fill style, stroke style, line width.  They're all camelcased.  You can put in all the styles.  You can take colors, put any HTML color in there, RGB, HSL, dark orchid.
Fill rect, immediately, pass it in XY, width and height.  Arguments.  And it immediately renders on the to the canvas.  Immediate load.  Doesn't keep the memory of this rect.
There is no Canvas method for a circle.  You have to draw and make an arc.  There's a radius, start and end angle.  You don't have to draw a circle.  Use this for pie charts.  Generate the arcs of a pie chart.  But this is a circle.
Code like this, you know, this is imperative code.  And I think imperative code is great for beginners.  It's line by line, something is happening.  And that's kind of the way  it's good to learn to read code that way and see things happening.  Eventual we want to sort of create words, which are more expressive ways of talking about things.  Here is a word for sort of a metaphor for circle.  What it will do is it will pass in X, a Y, a radius and a color.  And it will immediately fill the color on the screen.  We can create the exact same image I showed a moment ago with the circle function.  It looks a lot smaller.  So don't be afraid to define and play with functions.  Also, once you are making a visualization, you may find that this particular circle, as defined here, doesn't really fit what you need to do.
You may be annoyed that it sets the fill style.  Because after I have drawn this red, still blew, anything after this will be a steel blue.  Canvas, once you set it, it stays that way unless you go back and change it.
I have a sort of sequence here exploring the lab color spaces.  It's a perceptual color space available with D3.  This is the first D3 method we're going look at.  It takes three arguments, L, A, and B.  I have defined them here as variables.  And we're filling a rect that fills the screen.  This is just picking a single color in lab space.  You can take the return color of D3 lab and set it to lab style.
We can make a gradient but using D3 range.  Creates an array.  An array the same width as the canvas and reiterate.  We're doing something on every pixel of this canvas.
This little kind of scary mathy bit, what it ends up doing is it ends up going from negative to a hundred, which are the valid values for this A parameter in lab space.  For each one, draws a slice, full height across the canvas.
We can take a 2D section of the lab space by nesting yet another loop and doing the same thing on the B parameter.  And then we can trip out with D3 timer here.  Oh, no.
Ah.  I changed the order of my slides.  I made this code not run on this slide.
[ Laughter ]
All right.  Let's get that slide if I have time at the end.  It was cool.  It was cool.
[ Laughter ]
Here's another example of D3 timer.  This is a GIF.  It's not a live example on the page.  Turned out to be a mistake.  What D3 timer does, it takes a function.  And it will just keep running that function.  Internally it uses request animation frame.  It sounds scary.  What it is, is basically request animation frame will go to the browser and say, hey, are you doing anything right now and the browser will say, no, I'm not.  And request animation frame will say run this function.  And the browser says okay.  And request animation frame 16 seconds later will be like, are you doing anything now?  The browser, you just asked me that.  Well, run that same function again.  That's the request animation frame in D3 timer.  Runs the function over and over again.  And the function it runs, it passes in the elapsed milliseconds since you started.
So  whoops.  I'm using it here to  with satellite JS to just plot satellite.  The way the code works, it creates a date, gets the current time, adds on 150 times the ops, it's basically running time at 151X speed.  And then this data object  I'm not going to talk about loading data.  This is more a talk about rendering.  So I'm loading data.  They're TLEs from the track, the orbital parameters of a satellite.  I'm running the plot numbers, passing the data and time.  I use satellite JS.  This is kind of pseudo code here.  The structure is right, but some of the methods and arguments are a little different.  It propagates out that satellite to a time in the future so it's running it through its orbit.
Takes the position of the satellite at the time, and now it's a position in space.  Remember, the earth is rotating while the satellite is going.  And you can pass it directly into satellite GIS to get the coordinates sort of where the satellite is directly above and draw it.  And there's a map above, I'll get to that later.
This is another astronomy data set, the exoplanets.  This is the only demo I'll load externally.  My first OpenVis Conf talk was about this.  This uses Canvas move to and line to render these lines across the chart.  There's a double loop.  There's a loop iterating through every data, every exoplanet.  And across every dimension, the discovery letter, number of planets in the system.  Each of these dimensions has its own scale.  So as it renders, it goes and gets it and knows where on the axis it needs to hit.  Also, when any interaction happens on this canvas I do kind of a trick.  I have a utility called render queue.  It uses it to render the data slowly.  Why would you want to do that?  The reason is there's 3500 exoplanets almost.  If you tried to render every exoplanet every frame it takes a couple seconds.  A second or two.  Any interaction you would do in that time, scrolling, brushing, almost anything else on your computer, your CPU would just be like, you know, totally maxed out for that moment while it was trying to get everything on the display.
So I use render queue to render it slowly.  They are quick even if it's rendering.  You can interrupt these reactions.  The code for that is a little tricky.  I'm not going through it.  Once you draw something on Canvas, there's no cost to keep it around.  If you have a way to stream in data and stream on to canvas, you can render gigabytes of data on to a canvas.
Another trick is particle trails.  You can create this sort of whimsical effect in Canvas very easily.  Every frame of  in the canvas.  Usually you clear it every frame and render is anew.  Because it's not that expensive to render things in Canvas.  And if you want a particle trail instead of clearing everything, put a transparent rect over it.  And every frame you do that and get these trails almost for free.
So I also want to talk about learning.  In Canvas and SVG, I found this developer roadmap thing which kind of bugs me because, you know, this is like the path to become a developer, CSS, CS6, JavaScript, you play with TypeScript, Webpack, Angular, React.  CSS with, learn Flexbox.  And then play with SVG and finally get to learn D3.  You know who will never do this?  Is like 99.8% of the population.  I mean, this is a  it's an incredibly complex like the ecosystem right now.
SVG itself I think has some challenges to learning.  This looks like a boring slide.  Trust me, it's very inflammatory in the D3 community.  This slide.  There's a lot of complexity involved in managing a DOM hierarchy.
And in the relationship between SVG and HTML and CSS and adders and styles.  Path strings have their own language.  So you have to do string concatenation.  If you have tried to learn D3, you have probably struggled what's happening between the methods.
merge and transition, append.  And it gets slow with about a thousand elements.  But there's tons of tutorials out there.  We have invested, as a community, maybe tens of thousands of hours of developing beginners materials using SVG.  I think a lot of people who learn D3, they struggle and we get frustrated.  And I've even  I mean, I've known a lot of people who have learned D3.  I think some people have struggled with a mild depression at some point trying to learn it.
And these people laugh because they know it's true.
[ Laughter ]
I'm not being hyperbolic here.  I think it's because it's different than other technical tools you learn.  You want to learn D3 to express something and you have a vision of what you want to express.  And you see the amazing work by The New York Times.  You have a story you want to tell and you have a unique perspective.  And all this technical stuff gets in the way and you're stuck somewhere on some bug.  You have no idea why this thing is not happening or this line is being drawn that way or something.  It happens to a lot of us when we're learning.  I think almost everyone has this experience.  Even people who program and come into it.  Pay no attention to this slide.
Canvas is perfect.
[ Laughter ]
One thing I do want to mention is that the really  one of the big things you lose  I'll show you how to get some of these things back.  But I don't have a solution here for an accessibility fallback.  With SVG you get  for free, or with a little bit of effort  support for screen readers and other accessibility tools.  You do not get that from Canvas.  People, if they can't see, they can't experience your work.
This is a New York Times graphic.  How the epidemic of drug overdose deaths ripples across America.  It's about opioids and related to others  these diseases of despair.  These are choropleth maps.  I don't know if that data comes from CDC wonder.  If you are interested in that, CDC wonder is a great place to start.
You can get breakdowns by year of death, age group, race, gender, cause of death, where they died, if they died in hospice facility.  Choropleths in D3 is pretty easy.  Geopath supports taking a Canvas context.  So whenever you pass geoJSON into the path.  And I know if you haven't learned D3, you're going get lost in terms of the technical examples for the rest of the talk.  I apologize for that.
And do all the same Canvas stuff, and when you're ready to render a path, pass the geoJSON into the path and run it.  You can pick the projection.  Almost everything you do in D3, GO, almost everything you can do in D3, you can do with Canvas.  You can get retina support with in little thing.  The device pixel ratio.
Basically like this display has twice as many pixels as what it sort of reveals to the canvas.  It basically by default things look funny.  It's a retina highdensity display.  A lot of displays are like this now.  That means for every pixel that it looks like it has when you say font size 13 pixels, there's two pixels in both directions.  So four pixels for every one.  If you want that level of detail on every pixel on this display, you need to put this chunk of line of code.
Here's another advanced trick.  If you're a beginner  this is hitting Canvas lookups.  A common complaint with Canvas is you can't select objects on the Canvas, there's nothing there.  It's just a bitmap.  This is a trick I want to put out there.  It works can a lot of visualizations.  You can create a second Canvas that you use as a lookup.  Basic life put a unique color for every object you have rendered and save that mapping from the colors to the original data into a JSON file.  And then whenever a Canvas  mouse event happens on the screen  you get image data to get the color off your hidden canvas and you can look up the original file.  And you can add tool tips.  Yannick from Bocoup has a great blog post on this.
A couple other interactions, with D3 quad tree.  A lot of people use Voronoi diagrams.  And you can maximize the area that you can interact with a point on a visualization.
If you use a quad tree and just search for the nearest point, you get the exact same interaction service.  So in this sort of example running in the background, it's a bunch of Voronoi being drawn on a canvas.  And I use quad trees to see which Voronoi is being highlighted.  It creates the exact same interaction service if you use it that way.
There's a new simulation in version 4, simulation.find.  It's pretty easy to do.  There's a lot of examples of the forced layout in Canvas with interactions.  And the forced layout is pretty fast.  If you have only used the forced layout with SVG, the biggest bottleneck is SVG.  It can support tens of thousands of nodes and almost up to 10,000 almost no problem.
Sorry.  Tens of thousands of objects.  So I'm talking about nodes and edges.  So here I think there's about 6,000 if you add up all the nodes and edges.
D3 path in version 4.  I think it's a new utility.  I forgot, actually.  But it makes available these Canvas methods.  So these are all methods that are available on the Canvas.  If you use them in D3.path, it can render to canvas and do that.  If you're only using Canvas, there is a big reason to use it.  At least I can't think of one off the top of my head.  But you can generate SVG path strings.  And it's actually used for all of the V4 shape generators.  Arcs, pies, lines, generators, stacks.  All these are built on a D3 path.  They, too, can render to Canvas.  All these shape generators can do this in version 4 of D3.
We have a huge problem, I think, in terms of educating new people on how to use D3.  I think the learning curve is extremely steep.  I think a lot of people get discouraged because it may be their first time programming.
And I think it's a critical moment when someone says, you know, I'm ready to take this active relationship, you know, with the computer and actually learn how to program the computer to make images.  Because, I mean, for whatever reason that they decide to do that.  And they hit this wall of complexity and, you know, fail to really get to a point where they feel comfortable.  You know, they're less likely to try it again.  And if they do try it again and fail again, they're not able to get that place where they feel comfortable and they're able to express themselves.  And they probably won't try a third time.
If we have this complexity in the learning process sitting there, we're going to lose a lot of people just as sort of attrition of people who, you know, have worthwhile stories to tell.  I have never met someone who  sorry.  I've met a lot of people who are wanting to learn D3 and are struggling to learn D3.  And they'll tell me why they're wanting to learn D3.  It's a worthy story they're trying to tell.  And often a complex story and a story I have never heard before.  I had the privilege to work for several years at Stamen design.  One of my favorite habits there is when we were making prototypes and creating stuff, sometimes we would just have an idea.  And people will put their laptops on the floor like this.
We kind of do it just  I guess it's the height of the couches.  But also because it sort of minimizes the area that the laptops take.  And at that point, you know, an idea is consuming us and we're talking around the room and we're, you know, thinking and talking and brainstorming.  And the data and the ideas in the computer have leapt off the page and are now in the room and we're thinking about them and we're brainstorming.
And I think that's really the goal of visualization.  I'm talking about pixels and things.  But pixels, you know, it's just a mechanism to get these ideas into our minds.  To be able to think about it and have this relationship with data.  Especially, you know, there's no way to have a relationship with a gigabyte of data unless you're using computers somehow, some tool to internalize it.  I was inspired to learn data visualization by this wonderful talk by Hans Rosling.  He explains that you have seen 30,000, 40,000 bits of data.  At no point was I overwhelmed.  I know I could go back and look at all the details of this visualization.  We have this incredible capacity to consume a large quantity of data.  Especially when you have the right person to sort of guide us through the data and tell that story.
And so I think we need more people in our community who are that person.  Who have that vision of the story that they want to tell.  So I hope you will rise to the challenge of thinking about this problem of how to make learning D3 and learning programming more accessible to a broader audience.  Because it would greatly benefit us.  And the stories we're capable to tell by having that diversity.  That's all I have.  Thank you very much.
[ Applause ]

