Vega-Lite: A Grammar of Interactive Graphics
Kanit �Ham� Wongsuphasawat, Dominik Moritz, Arvind Satyanarayan

>> I'm excited to get our next set of speakers.  We have three folks who are going to talk to us.  Which is really exciting.  We have Arvind and Ham and Dominik all working here at the University of Washington.  And you've seen them in various permutations here before at OpenVis Conf talking about all the exciting tooling work that they have been doing from Vega to Voyager to Pulsa.  And we're excited about the work they're doing, VegaLite.  And we're excited about.  Welcome, guys.
[ Applause ]
>> Hi, OpenVis Conf.  Our team from the interact data lab at the University of Washington is happy to present VegaLite.  Interactive graphics.  So we have so many languages for creating visualizations and we like them for so many reasons.  Why do we need another language this?  This will be a walkthrough of what we like about this language and how VegaLite goes beyond the languages.  This is an expressive range of graphics.  Many adopt the idea from the grammar of graphics.  Just like how grammar helps us compose words into sentences in English, graphics provide building blocks for creating visualizations.  For encoding this includes data that we want to visualize, graphical marks, bar, point and line.  The encoding mapping between the data and property of these marks.  Scale or function that map data values to visual values.  And including access to legends that visualize the scale functions.  With these building blocks for the custom designs such as D3 and Vega are for composing interactive graphics.  However, these require some technical expertise.  For example, creating a simple bar chart in D3 requires a few dozen lab coats and knowledge of JavaScript and so on.  In contrast, exploring data and design, such as ggplot and Tableau are more concise.  By emitting lowlevel details such as scale and guides.  These have sensible defaults for the properties.  They allow customization by allowing users change default values.  However, they provide immediate support for interaction techniques.
VegaLite provides an expressive, yet concise language to specify multiview graphics.  And unlike the others, it gives a language to express the encodings.  VegaLite goes beyond the traditional graphic by providing operations for composing multiview graphics.  And we present building blocks for composing interactions using selections.  With VegaLite, all of these building blocks are in a single, unified language.  In this talk we will first show you the design of VegaLite.  We will then show you how you can use VegaLite as a programming tool and how it can enable higher level application and recommendations.  Next, Dominik is going to show you a use in VegaLite.
>> When grafting a visualization, we create a visual representation of abstract data to amplify cognition.  The main is to show how abstract data should be encoded visually without low elf details such as axis, scales and how to draw these.  Take, for example, this abstract data with records for Seattle.  The raw data has no inherent visual representation.  To see the spread of temperature on the left, the analyst can decide to Crete a strip plot.  In VegaLite, it's specified by encoding data properties of marks.  A strip plot is a visualization where we encode the data value as the exposition of a tick mark.  Temperature is a quantitative variable that shows a magnitude.  In our syntax, you need to specify the data source.  Then the mark as data representative mark.  And most importantly, the mapping of data values to visual for this mark.
The language is declarative JSON which is easy to process with common programming languages and native to the Web.  Behind the scenes, the VegaLite compiler resolves ambiguity about scales and axis.  And with reasonable defaults.  Omitting these details allows you to be precise.  And they follow best practices in visualization and potentially a style guide.  However, users can override the decisions made by the compiler to customize a chart.  The strip plot we created shows the spread of temperature in Seattle, which ranges from a couple minus degrees Celsius to around 30degrees.  Okay.  But looking at the strip plot, we can see the spread, but note how many days have a particular temperature.  A histogram shows the number of records that fall into particular ranges.  In other words, histograms visualize a distribution.
A histogram is just a bar chart with the underlying� with a bar as the underlying mark.   The exposition of the bars is determined by a field.  And thing a gated count maps to the vertical position, or the length of the bar.
How might we transition from this tick mark� sorry, from the strip plot� to the histogram?  First, let's get the temperature data.  Now the temperature is able to be aggregated.  We can include the count aggregate as the length� sorry, the wide position of the tick mark.  And then, finally, switch from a tick mark to a bar, which creates the histogram.  And so now you know how to create a histogram for quantitative data in VegaLite.  To help you make sense of histograms, VegaLite uses a bending diagram to quantify the data in a human understandable way.  And beyond that, it goes to bending.  We bend the axis with a provisional challenge.  Instead of showing an ordinal axis, there was a quantitative axis as the guide.  We know that position is highly discriminatory.  And we can use a high number of bits.  And we can use a channel, number, capacity or shape, VegaLite creates a legend with the guide, and viewer bins.  Color in this case is less discriminating.  Having a visualization grammar allows tows reason about the specification and optimize the visual output as we have seen.  With the grammar, we can optimize the chart, as I have shown, or add encodings.  For instance, if we encode the dominant weather type with color, we get a histogram that shows us what it was on day with the particular temperature.  Let's look at this and better associate with the feelings for the weather types.  Such as gray for fog.
When we add the color encoding�with the VegaLite, it stacks the bars instead of layering on top of each other.  Because of the stacking, the overall shape of the histogram is preserved as you can see on the right.  To do this reasoning, the VegaLite compiler took into account the channel, which was color, and the mark, the bar.  And enabled stacking, a layout transform.  So three components interacted in a nontrivial way.  And created a chart that is more expressive than a bar chart with overlap.  To show you this overlap in the left side, I can overlay the bar chart with the line chart.  And you can notice that the barfs completely hidden behind the other bars.
This next histogram more accurately shows the data than the native version would.  However, it may still be hard to compare bars for particular weather.  For instance, it is hard to see how these two bars compare, because they do not share a common baseline.
We can change this by switching from a color encoding to a row encoding.  And this way we lay out the bars in space.  And this is the first example of layered and multiview composition in VegaLite.  VegaLite has a grammar to compose views in new ways to fit new opportunities.  The grammar has four basic operators.  You have already seen the facet operator.  It petitions the data by an ordinal field and creates a view for each petition.  Facet is the only operator where each view gets a view of the operator.  In the other operators, they all get full access to the data.  The layering operator stacks multiple views on top of each other.  And with con cant nation, you can create multiview displays.  And it's a precise way to concatenate the charts.  As a way to walk through the operators, I will use a bar chart that shows monthly precipitation in Seattle.  It is beautiful, but we try to scare people away by claiming that it always is raining all the time.  In this chart, the X axis is the date, grouped my month using the time unit keyword.   The length of the bars shows the mean precipitation per month.  And you can see in July it's actually quite low.
The layer operator allows us to draw multiple plots on top of each other.  This is useful, for example, to add annotations to a chart.  To add it, you nest specification under the layer keyword.  We can then add a second specification to the list of views.  In this case, one that shows the mean precipitation using a rule mark.  Note that we only specify the Y position of the rule so that we get the overall average throughout the year.  The two layers automatically share an X and Y axis, and the rule spans the width of the whole chart.
Another operator is concat.  To use it, you take a single view and visually concatenate with other views.  In VegaLite, you invoke concatenation by making multiple single view and array them under the keyword.  A reoccurring design pattern we identified is that concatenated views are the same specification, just using different fields.  And because it's common, we promoted it to it ounce operator and called it repeat.  We start with the specification of a single view.
Then we nest the specification and add some parameters.  The first one is a list of fields that we want to create views for.
And secondly, we update any field reference that we want to switch out to the repeated field.  And now the repeat operator creates a view for each value in the list.  So we get one view that shows the precipitation, one for the temperature, and one for wind.  With repeat we can create multiple charts that are similar, but use different fields.  And we can do so in a datadriven way.
You can also take this a step forward and use the repeat operator to repeat over multiple lists.  The operator then created a view for each entry in the cross product of the tool lists.
And the result of repeating a single scatterplot is a scatterplot matrix, or Splunk for short.  Of course, you can repeat arbitrary views, not just scatterplots.  They are used to investigate the relationship between multiple variables, for example, as a part of a dashboard.  You can use VegaLite or any other visualization library to create dash boards with many views.  Some may be composed.  However, as you put together the displays, you have to manage the data and lay out the views.
This is where the grammar aspect of composition comes into play.  Let's dissect the dashboard on the left.
First, we have the single views.  And we then use facet, repeat and layer to lay them out in space, combine, or annotate.  In VegaLite we can then recombine these composed views again using the four basic operators that you have already seen.  For instance, the threelayered views on the right can be created in a datadriven way by repeating the layer.  But this hierarchical composition can continue.  We can take the output of the repeat operation and concatenate it with the SPLUM.  And then again with the display at the bottom.  So now we have a complete dashboard described with a single specification, and because it is declarative, VegaLite can optimize the underlying data flow and the visualizations.
The VegaLite JSON specification for describing hierarchical composition is as you would expect it.  In the specification, you can use a nested specification in place of a single view specification.  And VegaLite automatically reasons about how data management and scales and axis should be combined.
Dashboards are a powerful way to look at multidimensional data.  However, to interrogate the data further, you want to interact with linked views and uncover hidden relationships.  And now Arvind is going to show you how to express these in VegaLite.
>> All right.  So the core abstraction to do interactions in VegaLite are these things called selections.  And they're very much analogous to how the encoding channels work.  So they define the defaults for three components.   The first is the event processing that happens, or what triggers the particular interaction technique.  Are they mouse moves?  Button presses?  So on and so forth.  The second is, what are we interacting with on our visualization?  Data couples or marks�things like that?  And finally, this thing, a predicate function, a bullion function that allow uses to select more points than we interacted with.  And let's make it more concrete with an example.  So here is a simple VegaLite specification for a scatter plot.  We're showing the horsepower, the mile per gallon, and all the cars are colored by the country of manufacture.  Now, the most basic definition for selection is a name and a type.  And we can use some conditional logic to change the color of the points based on what is being clicked.  So how is this interaction working?  It's the selection type that's driving a lot of the default values.  In particular, the single selection is saying on click sect a single point.
Now, I can swap out that single with an alternate type like multi to be able to select multiple points.  And now what the defaults are saying on the first click, select a point.  And on additional shift clicks, just toggle in or out.  Now, just like the encoding channels, I can go ahead and override the defaults.  Drive the interaction using mouse hovers.  And I get the paint brushing effect maybe to indicate a region of enter in my data set.  But if I had to always override the defaults, interactive specification would be very tedious.  The mic went.  Now it's back.  So besides these selections, in VegaLite we also introduce selection transformations.  Now this, you know, should sound analogous to data transformations, and they are.  So they're manipulating some part what have it means to be a selection.  So here is our single selection from earlier, and as a data analyst, we might have a question of, well, how does the number of cylinders a car has play into the question of horsepower.  I can answer the question by invoking something called a project transform.  What it does is it rewrites the predicate function a selection uses so when I click a particular point, all the points that share the same number of cylinders are highlighted as well.  With this interaction, I'm able to see the three groups of cylinders.  The eight at the bottom, the six at the mid-range, and the four at the top.  But just sort of this direct manipulation clicking doesn't give a sense of how exhaustively am I searching through my data set.  Are the cars three or five?  I don't know.  And I probably don't have a good way of finding out.  And so besides sort of direct manipulation, we can also invoke a transformation to add some dynamic query widgets to our interaction.  Now not only does the same clicking interaction work, but the rain slider back and forth, ahha, there are three and five cylinder cars, but only a handful, so I was not likely to click on them.  And because VegaLite is such a concise visualization language, we can make very small changes to rapidly generate and evaluate hypothesize.  So I have added a couple lines of additional code and now looking at the effect that year has on this trend.  And perhaps luckily for us we're seeing that as I scrub that year slider forward in time my cars are more efficient.  Timelines moving up the scatterplot.  But all of these selections and selection transformations are part of a grammar of interaction.  Not talking about interaction templates whatsoever.  So they're reusable across a variety of selection types.  So here, for example, is a continuous region selection called an interval.
And by default, allows me to select a region in both the X and Y dimensions.  But I can go ahead and use my transform to restrict to a single dimension, here the X axis, or excuse me, the project transform to restrict to that, and then the bind transform to bind.  Any guesses what will happen when I do that?  This happens.  I start panning and zooming my scatterplot.  This can feel magical, but let's unpack what's happening.  What's happening is we're establishing a twobay binding between the selection and the scales.  The selection is populated by the scale domains, and the scale domains themselves are being driven by the selection.  And all the interactions I have shown so far have been restricted to these single views.  But the reason we designed the multiview operators alongside the grammar of interaction, these interaction techniques are most effective when we're coordinating multiple distinct visualizations.  I can make a repeat operator to go from a single to a matrix of scatterplots and brushing and linking between them.  And another interval selection to pan and zoom to all of these cells in concert.
And with these sort of selection and transformations, a whole number of custom techniques fall out naturally.  I can set up an overview plus detail or focus plus context interaction might look like.  I have an area chart, I can concatenate with another area chart.  And in the top chart, add an interval selection to give me a brush mark.  And in the bottom, I use that brush to drive that detailed interaction.
And the final example with interaction that I wanted to walk through is how we might do a variant of crossfiltering.  So we'd start with a histogram, this is flights data.  And we have the binned hour that the flights took off along the X axis.  And we can repeat for other dimensions in the data set.  So the delay and the distance of these flights.  Now, this is� we want to go for a layered interaction.  We can add a second layer and color that layer in gold.  What the interaction technique is going to do is have the gold bars fill in the blue bars instead.  So we have the visual encoding set up.  Collapse it down and focus on the interaction specification.  So, of course, to do crossfiltering we need an interval selection and gives us a brush in each of our histogram.  And this is crossfiltering.
So the final step is to take that brush and filter our data.  And that's all we need to get this sort of crossfiltering interaction working.  And what we're talking about is 35 lines of JSON in a very composable manner like I have shown here.  Ham is going to walk us through the last smart how to use VegaLite in a number of applications.
>> Cool.  First see how you can use VegaLite as a programming library.  To use VegaLite, provide compiler that compiles a VegaLite specification into a lower level specification.  You can use run time and create it on the Web or a server.  Render up to Canvas or SVG.  If you like Canvas, like Kai in the talk this morning, you can change it and use it in Canvas.  And you can utilize the architecture for streaming data.  And another part is that it's streaming, so suppose your organization has� you can organize the chart in the same organization.  By using a declarative JSON syntax, it can serve as a file format for authoring and sharing visualizations.  And in addition, it can support binding for different languages.  To perform interactive analysis in Python, you can use a library led by Brian Granger.  And we can create this histogram that we have shown earlier, using a native Python API that maps directly to the syntax.  This can be convenient if you do data analysis in Python and Jupiter.  We would like to highlight Altair auto's API is automatically generated from the VegaLite JSON schema.  They need to push a button and get their API updated.  So not limited to just Python.  There are also other projects that try to wrap VegaLite in other languages as well.
So give you a sense of how well this has been received, in a recent article by Dan Saber, compared different data visualization libraries, it's the one to one to one mapping between thinking code and visualization, that is my favorite thing about Altair and the visualization design.  And the Altair team was excited about this, and said VegaLite was the best for data visualization.  So in addition to using VegaLite as a programming tool, VegaLite can also enable higher level applications that automatically generate recommendations.
For example, I would like to show voyager, a visualization tool that augments manual specification with recommendation to promote breadth and reduce tedium in exploration.  To support this goal, it was data encoding to make visualizations.  Here is the voyager interface about cars.  In voyager, it's multiple interactions to explore data.  Before you have to manually create a view.  And you would have the initial view.  This view helped analysts to establish different variables before diving into their relationships.  For example, we can see the distribution of the number of cars, we can see the distribution of others.  We can see that here many of them are here.  After examining different variables, you have the freedom to create any specific view using the interface similar to Tableau.  For example, dragging horsepower to the shelf, create a pod.  Like you have seen here.  Under the hood, VegaLite� sorry, voyager creates a VegaLite specification that maps horsepower to the channel and uses VegaLite to render the visualizations.  This specify view, just a different title for related views to help analysts in alternative ways to summarize or encode the data.
To recommend related summary views, we should first consider the VegaLite specification of the pod up here.  And determine if it can calculate its summary views by bending or computing.  We also consider that applying bending is particularly for the containing of value.  That's not so helpful.  So voyager also� and you get something like this.  But you can see that it might not be the best for this data.  So another part of this enumeration process, voyager also uses VegaLite to enumerate different alternative encodings and choose them based on perceptual effectiveness ranking.  In this case, this is the best mark for showing a histogram.
So that's how voyager used VegaLite to consider design alternatives and recommend a summary view.  Voyager also recommended other types of view such as those that show horsepower with other different variables.  This can help analysts consider a relationship that they might overlook if they have to manually create views.
To give you more control to create a collection manually, voyager has a wild card to specify a property of the visualization collection.  For example, on the left we have a list of wild card fields.  And if you drag quantitative fields, then we create scatterplots showing horsepower with our other quantitative variables.  Of course, use VegaLite in a number of quantitative field in the Y channel and under the hood.
With all these different interactions analysts can rapidly export different aspects of the data and create specific field visualizations to address their goals.
So we have seen that VegaLite can be used to support recommendations of data and visual encodings.  One area that we are excited about is applying a similar approach to recommend interactions.  With syntax for composed interactions, we can just add one small targeted change to a specification and get dramatically different interaction techniques.  With these changes, we can easily write a program to look at the interact and recommend interaction techniques as well.  To summarize, in this talk we have shown you the design of VegaLite which includes building blocks for taking single views and composing them into multiview graphics.  And VegaLite can be a programming tool on the Web or via wrappers.  And VegaLite can work with recommendations in a system like voyager.  Today, we are happy to say we are releasing VegaLite 2 beta.  It's including everything we have seen in the talk.  We have tutorial and documentation on GitHub.  And if you're interested, you can start playing with VegaLite in our online editor without the need to install anything.
And finally, we would like to thank our contributors to VegaLite and related projection.  Including a number of students at UDAP, our research collaborator, our colleagues at Bocoup, especially Kim and K. Adam.  And we would like to thank our research sponsor.  With that we hope you are excited about VegaLite.
[ Applause ]
